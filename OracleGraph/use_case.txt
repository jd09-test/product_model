Product Graph — Query Use Cases

Use Case 1
For each Class, show me how many distinct domain products are present in its Class (Port) or Dynamic Class (DynPort) relationships. Group the results by Class  name and then by relationship name, considering only the latest version of each Class.
SELECT gt.CLASS_NAME,
       gt.RELATIONSHIP_NAME,
       COUNT(DISTINCT gt.DOMAIN_PRODUCT_OBJECT_NUMBER) AS DOMAIN_PRODUCT_COUNT
FROM GRAPH_TABLE("product_graph"
  MATCH (c IS CLASSVOD)-[IS CLASSVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (c)-[IS CLASSVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP),
        (r)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN),
        (d)-[IS OBJECTRELATIONSHIPDOMAIN_REFERS_TO_PRODUCTVOD]->(p IS PRODUCTVOD)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
  COLUMNS (
    c.VOD_NAME AS CLASS_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    p.OBJECT_NUMBER AS DOMAIN_PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION,
    d.FIRST_VERSION AS DOMAIN_FIRST_VERSION,
    d.LAST_VERSION AS DOMAIN_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
  AND TO_NUMBER(gt.DOMAIN_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.DOMAIN_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.DOMAIN_LAST_VERSION))
GROUP BY gt.CLASS_NAME, gt.RELATIONSHIP_NAME
ORDER BY gt.CLASS_NAME, gt.RELATIONSHIP_NAME;


Use Case 2
For each product, show me how many distinct domain products are present in its Class (Port) or Dynamic Class (DynPort) relationships. Group the results by product name and then by relationship name, considering only the latest version of each product . show results only where domain count is more than N

SELECT gt.PRODUCT_NAME,
       gt.RELATIONSHIP_NAME,
       COUNT(DISTINCT gt.DOMAIN_PRODUCT_OBJECT_NUMBER) AS DOMAIN_PRODUCT_COUNT
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP),
        (r)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN),
        (d)-[IS OBJECTRELATIONSHIPDOMAIN_REFERS_TO_PRODUCTVOD]->(dp IS PRODUCTVOD)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    dp.OBJECT_NUMBER AS DOMAIN_PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION,
    d.FIRST_VERSION AS DOMAIN_FIRST_VERSION,
    d.LAST_VERSION AS DOMAIN_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
  AND TO_NUMBER(gt.DOMAIN_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.DOMAIN_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.DOMAIN_LAST_VERSION))
GROUP BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME
HAVING COUNT(DISTINCT gt.DOMAIN_PRODUCT_OBJECT_NUMBER) > 20
ORDER BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME;

Use Case 3
Show me all Class that have Class (Port) or Dynamic Class (DynPort) type relationships where no target class has been specified — meaning the relationship was created without filling in the Sub Object Class field.

SELECT DISTINCT gt.CLASS_NAME,
                gt.RELATIONSHIP_NAME,
                gt.RELATIONSHIP_ROW_ID
FROM GRAPH_TABLE("product_graph"
  MATCH (c IS CLASSVOD)-[IS CLASSVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (c)-[IS CLASSVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
    AND (r.SUB_OBJECT_CLASS_ID IS NULL OR r.SUB_OBJECT_CLASS_ID = '')
  COLUMNS (
    c.VOD_NAME AS CLASS_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    r.ROW_ID AS RELATIONSHIP_ROW_ID,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
ORDER BY gt.CLASS_NAME, gt.RELATIONSHIP_NAME;

Use Case 4 

Show me all Product that have a Class (Port) or Dynamic Class (DynPort) relationship which contains exactly one domain entry, considering only the latest version of each product.

SELECT gt.PRODUCT_NAME,
       gt.RELATIONSHIP_NAME,
       COUNT(DISTINCT gt.DOMAIN_PRODUCT_OBJECT_NUMBER) AS DOMAIN_PRODUCT_COUNT
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP),
        (r)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN),
        (d)-[IS OBJECTRELATIONSHIPDOMAIN_REFERS_TO_PRODUCTVOD]->(dp IS PRODUCTVOD)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    dp.OBJECT_NUMBER AS DOMAIN_PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION,
    d.FIRST_VERSION AS DOMAIN_FIRST_VERSION,
    d.LAST_VERSION AS DOMAIN_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
  AND TO_NUMBER(gt.DOMAIN_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.DOMAIN_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.DOMAIN_LAST_VERSION))
GROUP BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME
HAVING COUNT(DISTINCT gt.DOMAIN_PRODUCT_OBJECT_NUMBER) = 1
ORDER BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME;


Use Case 5
List all products in their latest version that have a relationship of type Product where both a product and a class are populated on the same relationship.

SELECT DISTINCT gt.PRODUCT_NAME,
                gt.RELATIONSHIP_NAME,
                gt.SUB_OBJECT_PRODUCT_ID,
                gt.SUB_OBJECT_CLASS_ID
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE = 'Product'
    AND r.SUB_OBJECT_PRODUCT_ID IS NOT NULL 
    AND r.SUB_OBJECT_CLASS_ID IS NOT NULL 
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    r.SUB_OBJECT_PRODUCT_ID AS SUB_OBJECT_PRODUCT_ID,
    r.SUB_OBJECT_CLASS_ID AS SUB_OBJECT_CLASS_ID,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
ORDER BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME;

Use case 6
Show me all product that have Class (Port) or Dynamic Class (DynPort) type relationships where no target class has been specified

SELECT DISTINCT gt.PRODUCT_NAME,
                gt.RELATIONSHIP_NAME,
                gt.RELATIONSHIP_ROW_ID
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(r IS OBJECTRELATIONSHIP)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND r.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
    AND (r.SUB_OBJECT_CLASS_ID IS NULL OR r.SUB_OBJECT_CLASS_ID = '')
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    r.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    r.ROW_ID AS RELATIONSHIP_ROW_ID,
    ver.VERSION_NUMBER AS VERSION_NUMBER,
    r.FIRST_VERSION AS REL_FIRST_VERSION,
    r.LAST_VERSION AS REL_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
ORDER BY gt.PRODUCT_NAME, gt.RELATIONSHIP_NAME;

Use Case 7
Find all products where, in their latest version, there are multiple active constraint rules that share the exact same Rule Specification. Show me the product details, the duplicated rule specification, and the list of duplicate rule IDs.

SELECT gt.PRODUCT_NAME,
       gt.PRODUCT_OBJECT_NUMBER,
       gt.PRODUCT_VERSION_NUMBER,
       gt.RULE_SPECIFICATION,
       COUNT(*) AS DUPLICATE_RULE_COUNT,
       LISTAGG(gt.RULE_ROW_ID, ',') WITHIN GROUP (ORDER BY gt.RULE_ROW_ID) AS RULE_IDS
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RULE_CONSTRAINTRULE]->(r IS CONSTRAINTRULE)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    p.OBJECT_NUMBER AS PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS PRODUCT_VERSION_NUMBER,
    r.RULE_SPECIFICATION AS RULE_SPECIFICATION,
    r.ROW_ID AS RULE_ROW_ID,
    r.FIRST_VERSION AS RULE_FIRST_VERSION,
    r.LAST_VERSION AS RULE_LAST_VERSION,
    r.ACTIVE_FLAG AS RULE_ACTIVE_FLAG
  )
) gt
WHERE gt.RULE_ACTIVE_FLAG = 'Y'
  AND TO_NUMBER(gt.RULE_FIRST_VERSION) <= TO_NUMBER(gt.PRODUCT_VERSION_NUMBER)
  AND (gt.RULE_LAST_VERSION IS NULL OR TO_NUMBER(gt.PRODUCT_VERSION_NUMBER) <= TO_NUMBER(gt.RULE_LAST_VERSION))
  AND gt.RULE_SPECIFICATION IS NOT NULL
GROUP BY gt.PRODUCT_NAME,
         gt.PRODUCT_OBJECT_NUMBER,
         gt.PRODUCT_VERSION_NUMBER,
         gt.RULE_SPECIFICATION
HAVING COUNT(*) > 1
ORDER BY gt.PRODUCT_NAME, gt.RULE_SPECIFICATION;

Use Case 8
Show me all products in their latest version that include the product ACT_IC_SP5 either directly in their relationships or inside a relationship domain.
a.Direct Product Relationship
SELECT DISTINCT gt.PRODUCT_NAME,
                gt.PRODUCT_OBJECT_NUMBER,
                gt.PRODUCT_VERSION_NUMBER,
                'Direct Relationship' AS PATH_TYPE,
                gt.RELATIONSHIP_NAME AS RELATIONSHIP_NAME
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND rel.SUB_OBJECT_TYPE_CODE = 'Product'
    AND rel.SUB_OBJECT_PRODUCT_ID = '88-1UAS1N'
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    p.OBJECT_NUMBER AS PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS PRODUCT_VERSION_NUMBER,
    rel.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    rel.FIRST_VERSION AS REL_FIRST_VERSION,
    rel.LAST_VERSION AS REL_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.PRODUCT_VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.PRODUCT_VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
ORDER BY gt.PRODUCT_NAME;
b.Domain Relationship
SELECT DISTINCT gt.PRODUCT_NAME,
                gt.PRODUCT_OBJECT_NUMBER,
                gt.PRODUCT_VERSION_NUMBER,
                'Domain Relationship' AS PATH_TYPE,
                gt.DOMAIN_RELATIONSHIP_NAME AS RELATIONSHIP_NAME
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP),
        (rel)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND d.SUB_OBJECT_PRODUCT_ID = '88-1UAS1N'
  COLUMNS (
    p.VOD_NAME AS PRODUCT_NAME,
    p.OBJECT_NUMBER AS PRODUCT_OBJECT_NUMBER,
    ver.VERSION_NUMBER AS PRODUCT_VERSION_NUMBER,
    d.RELATIONSHIP_NAME AS DOMAIN_RELATIONSHIP_NAME,
    rel.FIRST_VERSION AS REL_FIRST_VERSION,
    rel.LAST_VERSION AS REL_LAST_VERSION,
    d.FIRST_VERSION AS DOMAIN_FIRST_VERSION,
    d.LAST_VERSION AS DOMAIN_LAST_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.PRODUCT_VERSION_NUMBER)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.PRODUCT_VERSION_NUMBER) <= TO_NUMBER(gt.REL_LAST_VERSION))
  AND TO_NUMBER(gt.DOMAIN_FIRST_VERSION) <= TO_NUMBER(gt.PRODUCT_VERSION_NUMBER)
  AND (gt.DOMAIN_LAST_VERSION IS NULL OR TO_NUMBER(gt.PRODUCT_VERSION_NUMBER) <= TO_NUMBER(gt.DOMAIN_LAST_VERSION))
ORDER BY gt.PRODUCT_NAME;

Use Case 9
Show me all products in their latest version that contain at least one child product which is currently inactive. Include both direct relationships and relationship domain entries, and indicate which path each result came from.

Direct Path
SELECT DISTINCT gt.PARENT_PRODUCT_NAME,
                gt.PARENT_PRODUCT_OBJECT_NUMBER,
                gt.PARENT_PRODUCT_VERSION,
                gt.RELATIONSHIP_NAME,
                gt.CHILD_PRODUCT_NAME,
                gt.CHILD_PRODUCT_OBJECT_NUMBER,
                gt.CHILD_PRODUCT_VERSION,
                'Direct Relationship' AS PATH_TYPE
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(pver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP),
        (rel)-[IS PRODUCTRELATION_REFERS_TO_PRODUCTVOD]->(child IS PRODUCTVOD),
        (child)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(childver IS VODVERSION)
  WHERE pver.CURRENT_VERSION_FLAG = 'Y'
    AND childver.CURRENT_VERSION_FLAG = 'Y'
    AND childver.ACTIVE_FLAG = 'N'
  COLUMNS (
    p.VOD_NAME AS PARENT_PRODUCT_NAME,
    p.OBJECT_NUMBER AS PARENT_PRODUCT_OBJECT_NUMBER,
    pver.VERSION_NUMBER AS PARENT_PRODUCT_VERSION,
    rel.RELATIONSHIP_NAME AS RELATIONSHIP_NAME,
    rel.FIRST_VERSION AS REL_FIRST_VERSION,
    rel.LAST_VERSION AS REL_LAST_VERSION,
    child.VOD_NAME AS CHILD_PRODUCT_NAME,
    child.OBJECT_NUMBER AS CHILD_PRODUCT_OBJECT_NUMBER,
    childver.VERSION_NUMBER AS CHILD_PRODUCT_VERSION,
    childver.ACTIVE_FLAG AS CHILD_ACTIVE_FLAG
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.PARENT_PRODUCT_VERSION)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.PARENT_PRODUCT_VERSION) <= TO_NUMBER(gt.REL_LAST_VERSION))
ORDER BY gt.PARENT_PRODUCT_NAME, gt.RELATIONSHIP_NAME;

Domain Path
SELECT DISTINCT gt.PARENT_PRODUCT_NAME,
                gt.PARENT_PRODUCT_OBJECT_NUMBER,
                gt.PARENT_PRODUCT_VERSION,
                gt.DOMAIN_RELATIONSHIP_NAME,
                gt.CHILD_PRODUCT_NAME,
                gt.CHILD_PRODUCT_OBJECT_NUMBER,
                gt.CHILD_PRODUCT_VERSION,
                'Domain Relationship' AS PATH_TYPE
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(pver IS VODVERSION),
        (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP),
        (rel)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN),
        (d)-[IS OBJECTRELATIONSHIPDOMAIN_REFERS_TO_PRODUCTVOD]->(child IS PRODUCTVOD),
        (child)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(childver IS VODVERSION)
  WHERE pver.CURRENT_VERSION_FLAG = 'Y'
    AND childver.CURRENT_VERSION_FLAG = 'Y'
    AND childver.ACTIVE_FLAG = 'N'
  COLUMNS (
    p.VOD_NAME AS PARENT_PRODUCT_NAME,
    p.OBJECT_NUMBER AS PARENT_PRODUCT_OBJECT_NUMBER,
    pver.VERSION_NUMBER AS PARENT_PRODUCT_VERSION,
    d.RELATIONSHIP_NAME AS DOMAIN_RELATIONSHIP_NAME,
    rel.FIRST_VERSION AS REL_FIRST_VERSION,
    rel.LAST_VERSION AS REL_LAST_VERSION,
    d.FIRST_VERSION AS DOMAIN_FIRST_VERSION,
    d.LAST_VERSION AS DOMAIN_LAST_VERSION,
    child.VOD_NAME AS CHILD_PRODUCT_NAME,
    child.OBJECT_NUMBER AS CHILD_PRODUCT_OBJECT_NUMBER,
    childver.VERSION_NUMBER AS CHILD_PRODUCT_VERSION
  )
) gt
WHERE TO_NUMBER(gt.REL_FIRST_VERSION) <= TO_NUMBER(gt.PARENT_PRODUCT_VERSION)
  AND (gt.REL_LAST_VERSION IS NULL OR TO_NUMBER(gt.PARENT_PRODUCT_VERSION) <= TO_NUMBER(gt.REL_LAST_VERSION))
  AND TO_NUMBER(gt.DOMAIN_FIRST_VERSION) <= TO_NUMBER(gt.PARENT_PRODUCT_VERSION)
  AND (gt.DOMAIN_LAST_VERSION IS NULL OR TO_NUMBER(gt.PARENT_PRODUCT_VERSION) <= TO_NUMBER(gt.DOMAIN_LAST_VERSION))
ORDER BY gt.PARENT_PRODUCT_NAME, gt.DOMAIN_RELATIONSHIP_NAME;


Use Case 10
I want to check if any inactive products are part of active promotions. Please do this in three steps:
Step 1 — Find all products that are inactive in their latest version.
Step 2 — For each inactive product found, get the list  of all their ancestors.
Step 3 — Take the complete list of products from Steps 1 and 2 and check whether any of them appear in any active promotions

Step1
SELECT p.VOD_NAME AS product_name,
       p.OBJECT_NUMBER AS object_number,
       ver.VERSION_NUMBER AS version_number
FROM GRAPH_TABLE("product_graph"
  MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(ver IS VODVERSION)
  WHERE ver.CURRENT_VERSION_FLAG = 'Y'
    AND ver.ACTIVE_FLAG = 'N'
  COLUMNS (p.VOD_NAME, p.OBJECT_NUMBER, ver.VERSION_NUMBER)
)
ORDER BY product_name;

Step 2
WITH ARRAY[:inactive_object_numbers] AS target_list
SELECT parent.PRODUCT_NAME,
       parent.PRODUCT_OBJECT_NUMBER,
       rel.PATH_TYPE,
       rel.CHILD_OBJECT_NUMBER
FROM (
  -- Path 1: direct product relationships
  SELECT DISTINCT p.VOD_NAME          AS PRODUCT_NAME,
                  p.OBJECT_NUMBER     AS PRODUCT_OBJECT_NUMBER,
                  rel.SUB_OBJECT_PRODUCT_ID AS CHILD_OBJECT_NUMBER,
                  'Direct'            AS PATH_TYPE
  FROM GRAPH_TABLE("product_graph"
        MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(pver IS VODVERSION),
              (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP)
        WHERE pver.CURRENT_VERSION_FLAG = 'Y'
          AND rel.SUB_OBJECT_TYPE_CODE = 'Product'
          AND rel.SUB_OBJECT_PRODUCT_ID IN UNNEST(target_list)
        COLUMNS (
          p.VOD_NAME,
          p.OBJECT_NUMBER,
          rel.SUB_OBJECT_PRODUCT_ID,
          pver.VERSION_NUMBER,
          rel.FIRST_VERSION,
          rel.LAST_VERSION
        )
       ) rel
UNION ALL
SELECT DISTINCT p.VOD_NAME          AS PRODUCT_NAME,
                p.OBJECT_NUMBER     AS PRODUCT_OBJECT_NUMBER,
                d.SUB_OBJECT_PRODUCT_ID AS CHILD_OBJECT_NUMBER,
                'Domain'            AS PATH_TYPE
FROM GRAPH_TABLE("product_graph"
      MATCH (p IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_VERSION_VODVERSION]->(pver IS VODVERSION),
            (p)-[IS PRODUCTVOD_HAS_RELATIONSHIP_OBJECTRELATIONSHIP]->(rel IS OBJECTRELATIONSHIP),
            (rel)-[IS OBJECTRELATIONSHIP_HAS_RELATIONSHIP_DOMAIN_OBJECTRELATIONSHIPDOMAIN]->(d IS OBJECTRELATIONSHIPDOMAIN)
      WHERE pver.CURRENT_VERSION_FLAG = 'Y'
        AND rel.SUB_OBJECT_TYPE_CODE IN ('Port','DynPort')
        AND d.SUB_OBJECT_PRODUCT_ID IN UNNEST(target_list)
      COLUMNS (
        p.VOD_NAME,
        p.OBJECT_NUMBER,
        d.SUB_OBJECT_PRODUCT_ID,
        pver.VERSION_NUMBER,
        rel.FIRST_VERSION,
        rel.LAST_VERSION,
        d.FIRST_VERSION,
        d.LAST_VERSION
      )
) parent
ORDER BY parent.PRODUCT_NAME;


Step 3
WITH ARRAY[:product_object_numbers] AS target_products
SELECT prom.PROMOTION_NAME,
       prom.PROMOTION_CONFIG_MODEL_ID,
       prom.PRODUCT_NAME,
       prom.PRODUCT_OBJECT_NUMBER,
       prom.PATH_TYPE
FROM (
  -- Path A: Promotion Item → ProductDefinition bridge
  SELECT pd.NAME AS PROMOTION_NAME,
         pd.CONFIGURATION_MODEL_ID AS PROMOTION_CONFIG_MODEL_ID,
         prod.VOD_NAME AS PRODUCT_NAME,
         prod.OBJECT_NUMBER AS PRODUCT_OBJECT_NUMBER,
         'Promotion Item ProductDefinition Bridge' AS PATH_TYPE
  FROM GRAPH_TABLE("product_graph"
        MATCH (pd IS PROMOTIONDEFINITION)
              -[IS PROMOTIONDEFINITION_HAS_ITEMS_PROMOTIONITEM]->(item IS PROMOTIONITEM),
              (item)-[IS PROMOTIONITEM_REFERS_TO_PRODUCTDEFINITION]->(pdef IS PRODUCTDEFINITION),
              (prod IS PRODUCTVOD)-[IS PRODUCTVOD_HAS_DEFINITION_PRODUCTDEFINITION]->(pdef)
        WHERE pd.ACTIVE_FLAG = 'Y'
          AND prod.OBJECT_NUMBER IN UNNEST(target_products)
        COLUMNS (
          pd.NAME,
          pd.CONFIGURATION_MODEL_ID,
          prod.VOD_NAME,
          prod.OBJECT_NUMBER
        )
       )
  UNION
  -- Path B: Promotion Item points directly to ProductVOD
  SELECT pd.NAME,
         pd.CONFIGURATION_MODEL_ID,
         prod.VOD_NAME,
         prod.OBJECT_NUMBER,
         'Promotion Item Direct Product' AS PATH_TYPE
  FROM GRAPH_TABLE("product_graph"
        MATCH (pd IS PROMOTIONDEFINITION)
              -[IS PROMOTIONDEFINITION_HAS_ITEMS_PROMOTIONITEM]->(item IS PROMOTIONITEM),
              (item)-[IS PROMOTIONITEM_POINTS_TO_PRODUCTVOD]->(prod IS PRODUCTVOD)
        WHERE pd.ACTIVE_FLAG = 'Y'
          AND prod.OBJECT_NUMBER IN UNNEST(target_products)
        COLUMNS (
          pd.NAME,
          pd.CONFIGURATION_MODEL_ID,
          prod.VOD_NAME,
          prod.OBJECT_NUMBER
        )
       )
  UNION
  -- Path C: Promotion Item domain product
  SELECT pd.NAME,
         pd.CONFIGURATION_MODEL_ID,
         prod.VOD_NAME,
         prod.OBJECT_NUMBER,
         'Promotion Domain Product' AS PATH_TYPE
  FROM GRAPH_TABLE("product_graph"
        MATCH (pd IS PROMOTIONDEFINITION)
              -[IS PROMOTIONDEFINITION_HAS_ITEMS_PROMOTIONITEM]->(item IS PROMOTIONITEM),
              (item)-[IS PROMOTIONITEM_DOMAIN_PRODUCTVOD]->(prod IS PRODUCTVOD)
        WHERE pd.ACTIVE_FLAG = 'Y'
          AND prod.OBJECT_NUMBER IN UNNEST(target_products)
        COLUMNS (
          pd.NAME,
          pd.CONFIGURATION_MODEL_ID,
          prod.VOD_NAME,
          prod.OBJECT_NUMBER
        )
       )
) prom
ORDER BY prom.PROMOTION_NAME, prom.PRODUCT_NAME, prom.PATH_TYPE;








